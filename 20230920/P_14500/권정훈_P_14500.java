import java.util.Scanner;

// 테트로미노
// 브루트포스는 경우의 수가 천 만 가지 이하일 떄 사용하자(1초 기준)
// 블록의 개수 19 * 최대 가로 500 * 최대 세로 500 * 블록 4가지 = 1,900만(2초 이내 가능할 듯?!)
public class P_14500 {
	
	// 테트로미노 배열
	// 1차원은 테트로미노의 유형
	// 2차원은 테트로미노 전체를 표현하기 위한 좌표의 모음
	// 3차원은 테트로미노의 각 좌표를 표현하기 위한 (x,y)의 값
	private static int[][][] tetromino = {
			
			// 좌표 확인용
			// 03 13 23 33
			// 02 12 22 32
			// 01 11 21 31 
			// 00 10 20 30

			{{0,0}, {1,0}, {2,0}, {3,0}}, // 긴 거 네 칸(가로)
	        {{0,0}, {0,1}, {0,2}, {0,3}}, // 긴 거 네 칸(세로)
	        
	        {{0,0}, {1,0}, {0,1}, {1,1}}, // 정사각형
	        
	        {{0,0}, {1,0}, {0,1}, {0,2}}, // 세칸에 하나 끝(위)
	        {{0,0}, {0,1}, {1,1}, {2,1}}, // 세칸에 하나 끝(오)
	        {{1,0}, {1,1}, {1,2}, {0,2}}, // 세칸에 하나 끝(아)
	        {{0,0}, {1,0}, {2,0}, {2,1}}, // 세칸에 하나 끝(왼)

	        {{0,0}, {1,0}, {1,1}, {1,2}}, // 세칸에 하나 끝 대칭(위)
	        {{0,0}, {1,0}, {2,0}, {0,1}}, // 세칸에 하나 끝 대칭(오)
	        {{0,0}, {0,1}, {0,2}, {1,2}}, // 세칸에 하나 끝 대칭(아)
	        {{2,0}, {0,1}, {1,1}, {2,1}}, // 세칸에 하나 끝 대칭(왼)
	        
	        {{0,0}, {1,0}, {2,0}, {1,1}}, // 볼록할 철(위)
	        {{0,0}, {0,1}, {0,2}, {1,1}}, // 볼록할 철(오)
	        {{0,1}, {1,0}, {1,1}, {2,1}}, // 볼록할 철(아)
	        {{1,0}, {0,1}, {1,1}, {1,2}}, // 볼록할 철(왼)
	        
	        {{1,0}, {1,1}, {0,1}, {0,2}}, // 으악뱀(위)
	        {{0,0}, {1,0}, {1,1}, {2,1}}, // 으악뱀(오)
	        {{0,0}, {0,1}, {1,1}, {1,2}}, // 으악뱀 대칭(아)
	        {{0,1}, {1,1}, {1,0}, {2,0}}, // 으악뱀 대칭(왼)
	};

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt(); // 가로
		int m = sc.nextInt(); // 세로
		int[][] map = new int[n][m]; // 종이 배열

		// 종이 배열 요소 입력
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				map[i][j] = sc.nextInt();
			}
		}

		// 갱신할 최댓값
		int max = 0;
		
		// 가능한 테트로미노의 모든 유형만큼 반복
		for (int i = 0; i < tetromino.length; i++) {
			
			// 블록 배열 생성
			int[][] block = tetromino[i];
			
			// 종이의 크기만큼 순회
			for (int j = 0; j < n; j++) {
				for (int k = 0; k < m; k++) {
					
					// 순회하며 구할 임시 합
					int tmp = 0;
					
					// 블록마다 확인
					for (int l = 0; l < 4; l++) {
						// 범위에서 벗어날 경우 넘긴다.
						if (j + block[l][0] >= n || k + block[l][1] >= m) {
							continue;
						} 
						// 범위에 들어왔을 경우 해당 좌표의 값을 더해준다. 
						else {
							tmp += map[j + block[l][0]][k + block[l][1]];
						}
					}
					
					// 최대값 갱신
					if (max < tmp) {
						max = tmp;
					}
				}
			}
		}
		// 정답 출력
		System.out.println(max);
	}
}
