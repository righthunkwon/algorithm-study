package dynamic_programming;

import java.util.Scanner;

// 1, 2, 3 더하기

// 동적 계획법
// 작은 부분문제들의 최적해를 이용하여 큰 문제의 해를 구하는 방법

// 1, 2, 3은 고정적으로 사용되므로 
// 우선 초기값으로 dp[1], dp[2], dp[3]을 구한다.

// 이후 각 경우를 열심히 써서 일반화를 하여 적절한 점화식을 도출해낸다.
// 숫자 4의 경우에는 1, 2, 3에서 각각 3, 2, 1을 더한 경우의 수이다.
// 숫자 5의 경우에는 1, 2, 3에서 각각 4, 3, 2을 더한 경우의 수이다.
// 숫자 6의 경우에는 1, 2, 3에서 각각 5, 4, 3을 더한 경우의 수이다.
// 숫자 n의 경우에는 1, 2, 3에서 각각 n-1, n-2, n-3을 더한 경우의 수이다.

// n = 1 일 때,
// 1
// 한 가지이므로 dp[1] = 1 이다.

// n = 2 일 때,
// 1 + 1
// 2
// 두 가지이므로 dp[2] = 2 이다.

// n = 3 일 때,
// 1 + 1 + 1
// 2 + 1
// 1 + 2
// 3
// 총 4가지이므로 dp[3] = 4 이다.

// n = 4 일 때,
// 1 + 1 + 1 +1
// 2 + 1 + 1
// 1 + 2 + 1
// 3 + 1
// 1 + 1 + 2
// 2 + 2
// 1 + 3
// 총 7가지이므로 dp[4] = 7 이다.

// 그런데 n = 4 인 경우의 수에서 아래의 밑줄 친 부분의 연산은 dp[3]에 포함된 경우의 수와 같다.
// 1 + 1 + 1 +1
// ㅡㅡㅡㅡㅡㅡ
// 2 + 1 + 1
// ㅡㅡㅡㅡ
// 1 + 2 + 1
// ㅡㅡㅡㅡ
// 3 + 1
// ㅡ

// 아래의 밑줄 친 부분의 연산 역시 dp[2]에 포함된 경우의 수와 동일하다.
// 1 + 1 + 2
// ㅡㅡㅡㅡ
// 2 + 2
// ㅡ

// 아래의 밑줄 친 부분의 연산은 dp[1]에 포함된 경우의 수이다.
// 1 + 3
// ㅡ

// 즉, dp[4] 는 결국 dp[3] + dp[2] + dp[1]을 더한 것과 같다.
// 이를 통해 dp[n] = dp[n-1] + dp[n-2] + dp[n-1]라는 점화식을 도출할 수 있다.
public class P_9095 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int tc = sc.nextInt();
		for (int t = 1; t <= tc; t++) {
			int n = sc.nextInt();
			int[] dp = new int[11];
			dp[1] = 1; // 1
			dp[2] = 2; // 1+1, 2
			dp[3] = 4; // 1+1+1, 1+2, 2+1, 3
			
			// DP
			for (int i = 4; i <= n; i++) {
				dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
			}
			System.out.println(dp[n]);
		}
	}
}
